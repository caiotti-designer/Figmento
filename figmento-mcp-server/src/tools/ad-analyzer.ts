import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

type SendDesignCommand = (action: string, params: Record<string, unknown>) => Promise<Record<string, unknown>>;

// ═══════════════════════════════════════════════════════════════
// CRITICAL RULES (extracted from MISSION.md v3 — battle-tested)
// ═══════════════════════════════════════════════════════════════

const CRITICAL_RULES = `
## CRITICAL RULES — Follow these exactly

### 1. Font weight — NEVER use 600
fontWeight: 600 silently falls back to Inter. Only use 400 (Regular) or 700 (Bold). Never 500, 600, or any other value.

### 2. fillColor and segment color do NOT persist
Do NOT rely on fillColor inside create_text OR color inside segments. Both are silently ignored — text renders black. Every text node needs a separate set_fill call immediately after creation.

### 3. tempId on every command whose output will be referenced
Any create_text, create_rectangle, or create_frame that will be referenced by a later command MUST have a tempId. tempId goes on the command object (sibling of action and params), NOT inside params.

### 4. Batch discipline
Use batch_execute for groups of related elements. Max 50 commands per batch. place_generated_image CANNOT run inside batch_execute — call it separately.

### 5. IMAGE_OUTPUT_DIR pre-flight check
Before calling mcp-image, confirm IMAGE_OUTPUT_DIR env var points to ./output/. Files generated by mcp-image go to generated-images/ by default — always cp to output/ before calling place_generated_image.

### 6. evaluate_design overwrites the same file on every call
Run evaluations sequentially, then immediately copy each result.

### 7. Overlay gradient — 2 stops only, color-matched
Only 2 gradient stops. Never 3+. Gradient color MUST match the section's background color. Direction: bottom-top. Position 0 = 0% opacity, position 0.4 = 100% opacity.

### 8. Accent colors need contrast checks too
Accent colors that work on fills may have terrible contrast as text on dark backgrounds. Verify accent text is readable. If luminance < 40%, lighten it for text use.

### 9. Content frames must HUG — never fixed height
Always set layoutSizingVertical: "HUG" on content frames, text-group, and cta-group. Fixed heights cause clipping.

### 10. Variant C must use a NEW generated image
Never reuse the original ad image for any variant — the original has baked-in text overlays. Generate a new lifestyle image for every variant. Only the copy stays verbatim in Variant C.
`.trim();

// ═══════════════════════════════════════════════════════════════
// TOOL REGISTRATION
// ═══════════════════════════════════════════════════════════════

export function registerAdAnalyzerTools(server: McpServer, sendDesignCommand: SendDesignCommand): void {

  // ─────────────────────────────────────────────────────────────
  // start_ad_analyzer — receives brief + image, saves to disk
  // ─────────────────────────────────────────────────────────────

  server.tool(
    'start_ad_analyzer',
    'Initialize the Ad Analyzer workflow. Receives the ad brief and base64 image from the Figmento plugin. Saves the image to disk and returns the brief, critical rules, and instructions to proceed with the MISSION.md workflow (Phases 2-5).',
    {
      imageBase64: z.string().describe('Base64-encoded ad image (PNG or JPG), without data URI prefix'),
      imageMimeType: z.string().describe('image/png or image/jpeg'),
      productName: z.string().describe('Product name from the brief'),
      productCategory: z.string().describe('Product category (e.g. Furniture, Fashion, SaaS)'),
      platform: z.string().describe('Target platform: instagram-4x5 | instagram-1x1 | instagram-story | facebook-feed'),
      channelId: z.string().describe('Bridge channel ID for sending design commands to Figma'),
      notes: z.string().optional().describe('Optional notes from the user'),
    },
    async ({ imageBase64, imageMimeType, productName, productCategory, platform, channelId, notes }) => {
      // 1. Ensure output/ directory exists
      const outputDir = path.resolve(process.cwd(), 'output');
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // 2. Decode base64 and save to disk
      const extension = imageMimeType === 'image/jpeg' ? 'jpg' : 'png';
      const imagePath = path.join(outputDir, `original-ad.${extension}`);

      // Strip data URI prefix if present
      const cleanBase64 = imageBase64.replace(/^data:image\/\w+;base64,/, '');
      const buffer = Buffer.from(cleanBase64, 'base64');
      fs.writeFileSync(imagePath, buffer);

      const absoluteImagePath = path.resolve(imagePath);

      // 3. Return brief + rules + instructions
      const result = {
        brief: {
          productName,
          productCategory,
          platform,
          notes: notes || 'None',
        },
        imagePath: absoluteImagePath,
        channelId,
        criticalRules: CRITICAL_RULES,
        instruction: [
          'The ad image has been saved to: ' + absoluteImagePath,
          '',
          'Now follow the MISSION.md workflow:',
          '1. Connect to Figma using connect_to_figma with channelId: ' + channelId,
          '2. Proceed with Phase 2 (Analyze the original ad image at the path above)',
          '3. Phase 3 (Generate improved images using mcp-image with inputImagePath)',
          '4. Phase 4 (Build 3 ad variants in Figma using the design tools)',
          '5. Phase 5 (Evaluate and create design-report.md)',
          '',
          'When the workflow is complete, call complete_ad_analyzer with the report markdown and carousel nodeIds.',
        ].join('\n'),
      };

      return {
        content: [{
          type: 'text' as const,
          text: JSON.stringify(result, null, 2),
        }],
      };
    }
  );

  // ─────────────────────────────────────────────────────────────
  // complete_ad_analyzer — sends report to plugin via Bridge
  // ─────────────────────────────────────────────────────────────

  server.tool(
    'complete_ad_analyzer',
    'Signal that the Ad Analyzer workflow is complete. Sends the design report and carousel node IDs to the Figmento plugin via the Bridge command pipeline, which displays the report in the plugin UI.',
    {
      report: z.string().describe('Full design-report.md content as markdown'),
      carouselNodeId: z.string().describe('Root carousel frame nodeId in Figma'),
      variantNodeIds: z.array(z.string()).describe('Array of [A, B, C] variant slide nodeIds'),
    },
    async ({ report, carouselNodeId, variantNodeIds }) => {
      // Send completion to plugin via existing Bridge command pipeline
      await sendDesignCommand('ad-analyzer-complete', {
        report,
        carouselNodeId,
        variantNodeIds,
      });

      return {
        content: [{
          type: 'text' as const,
          text: 'Ad Analyzer completion signal sent to the Figmento plugin. The plugin will display the report and offer a "View in Figma" button.',
        }],
      };
    }
  );
}
